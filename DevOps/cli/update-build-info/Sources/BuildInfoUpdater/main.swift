import Foundation
import ArgumentParser
import LillyUtilityCLI

/// LillyUtility.Git should handle some of the logics here
struct Git {
    let description: String
    let branch: String
    let commit: String
    let revision: String
}

struct BuildInfo {
    let date: Date
    let git: Git
}

/// This implementation is from Vega and should be updated at some point.
struct BuildInfoUpdater: ParsableCommand, OSRequired, StringUtilityRequired, Loggable {
    static var configuration = CommandConfiguration(
        abstract: "This script updates or reverts Generated/BuildInfo.swift",
        version: "0.0.1"
	)

    @Option(name: .shortAndLong, help: "Project root path.")
    var projectPath: String

    @Option(name: .shortAndLong, help: "BuildInfo.swift's file path under project root path; should be under some `Generated` path. Filename should also be included.")
    var filePath: String

    @Argument(help: "Command: `update` or `revert`")
    var command: String

    func run() throws {
        LoggerManager().setup(loggers: [
            TerminalLogger(),
        ])

        switch command {
        case "update":
            try updateBuildInfo()
        case "revert":
            try revertBuildInfo()
        default:
            print("Unknown command")
        }
    }

    func updateBuildInfo() throws {
        let buildInfo = BuildInfo(
            date: Date(), 
            git: Git(
                description: try os.shell("git describe").trimmingCharacters(in: CharacterSet.newlines),
                branch: try os.shell("git branch --show-current").trimmingCharacters(in: CharacterSet.newlines),
                commit: try os.shell("git rev-parse HEAD").trimmingCharacters(in: CharacterSet.newlines),
                revision: try os.shell("git rev-list HEAD | wc -l | sed 's/^[ \t]*//;s/[ \t]*$//'").trimmingCharacters(in: CharacterSet.newlines)
            ))
        try generateBuildInfo(buildInfo)
    }

    func revertBuildInfo() throws {
        try generateBuildInfo(nil)
    }

    private func generateDependency() throws -> [String: String] {
		let generator = try DependencyGenerator(path: projectPath)
        let dependencies = try generator.generateMarkdown()
        var result = [String: String]()
        try dependencies.components(separatedBy: CharacterSet.newlines).forEach { line throws in
            let array = try stringUtility.groups(line, pattern: "\\- (.*) \\((.*)\\)")
            if array.count > 0, array[0].count >= 3 {
                // Example:
                //  - FirebaseCore (6.10.3)
                //  [["- FirebaseCore (6.10.3)", "FirebaseCore", "6.10.3"]]
                result[array[0][1]] = array[0][2]
                // print(array[0][1])
            }
        }
        return result
    }

    private func generateBuildInfo(_ buildInfo: BuildInfo?) throws {
        let na = "N/A"
        var buffer = ""

        if let buildInfo = buildInfo {
            buffer += "// Do NOT commit changes of this file!!!\n"
            buffer += "// This file has been updated by iOS App Target - Build Phases - Run Script - Update Build Info on \(buildInfo.date)\n"
        } else {
            buffer += "// DO NOT EDIT THIS FILE MANUALLY!\n"
            buffer += "// 1. This file will be updated when you build/run/test/archive your project locally\n"
            buffer += "// 2. The changes will be reverted after building the project\n"
            buffer += "// 3. Do NOT commit changes of this file unless Step 4 is done\n"
            buffer += "// 4. To maintain this file, edit iOS App Target - Build Phases - Run Script - Clean Up\n"
        }
        buffer += "// Generated code may require underline in variable name(s)\n"
        buffer += "// swiftlint:disable identifier_name\n"
        buffer += "enum BuildInfo {\n"
        buffer += "    static let date = \"\(buildInfo?.date.description ?? na)\"\n"
        buffer += "\n"
        buffer += "    enum Git {\n"
        buffer += "        static let description = \"\(buildInfo?.git.description ?? na)\"\n"
        buffer += "        static let branch = \"\(buildInfo?.git.branch ?? na)\"\n"
        buffer += "        static let commit = \"\(buildInfo?.git.commit ?? na)\"\n"
        buffer += "        static let revision = \"\(buildInfo?.git.revision ?? na)\"\n"
        buffer += "    }\n"
        buffer += "\n"
        buffer += "    enum Pod {\n"

        let dependencies = try generateDependency()
        // print(dependencies)
        let pods = [
            "AppDynamicsAgent", 
            "Contentful",
            "Firebase/Core",
            "FirebaseCore",
            "GoogleAppMeasurement",
            "GoogleDataTransport",
            "OktaAuthSdk",
            "OktaOidc",
            "KalturaClient/Core",
            "KalturaPlayer/OVP",
        ]
        pods.forEach { pod in
            let name = pod.replacingOccurrences(of: "/", with: "_")
            buffer += "        static let \(name) = \"\(buildInfo != nil ? (dependencies[pod] ?? na) : na)\"\n"
        }

        buffer += "    }\n"
        buffer += "}\n"

        let url = URL(fileURLWithPath: projectPath + "/" + filePath)
        log("Writing to: \(url)")
        try buffer.write(to: url, atomically: true, encoding: .utf8)
    }
}

BuildInfoUpdater.main()
